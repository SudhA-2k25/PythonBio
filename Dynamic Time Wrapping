# DYNAMIC TIME WRAPPING
import math

t = [1, 1, 2, 2, 3, 5]
s = [1, 2, 3, 5, 5, 6]

col = len(t)
row = len(s)
tw = [[0] * (col + 1) for i in range(row + 1)]

for i in range(1, row + 1):
    tw[i][0] = math.inf

for i in range(1, col + 1):
    tw[0][i] = math.inf

for i in range(1, row + 1):
    for j in range(1, col + 1):
        diag = tw[i - 1][j - 1]
        left = tw[i - 1][j]
        up = tw[i][j - 1]

        tw[i][j] = abs(s[i - 1] - t[j - 1]) + min(diag, left, up)

for i in range(1, row + 1):
    for j in range(1, col + 1):
        print(tw[i][j], end="\t")
    print()

sum_val = tw[row][col]
print(f"The optimal edge is {sum_val}")



i = row
j = col
count = 0

while i > 0 and j > 0:
    diag = tw[i - 1][j - 1]
    left = tw[i - 1][j]
    up = tw[i][j - 1]

    if min(diag, left, up) == diag:
        i -= 1
        j -= 1
        sum_val += diag
        count += 1

    elif min(diag, left, up) == left:
        i -= 1
        sum_val += left
        count += 1

    elif min(diag, left, up) == up:
        j -= 1
        sum_val += up
        count += 1

optimal_path = sum_val / count
print(f"The optimal alignment path value is {optimal_path}")

# OUTPUT

0	0	1	2	4	8	
1	1	0	0	1	4	
3	3	1	1	0	2	
7	7	4	4	2	0	
11	11	7	7	4	0	
16	16	11	11	7	1	
The optimal edge is 1
The optimal alignment path value is 0.125

Dynamic Time Warping (DTW) is a technique used in time series analysis and pattern recognition to measure the similarity between two temporal sequences. It allows for the comparison of sequences with varying lengths and the detection of similar patterns even if they are warped or shifted in time.

The concept behind DTW is to find the optimal alignment between the two sequences by warping and stretching them in the time dimension. The algorithm calculates a similarity score based on the minimum cumulative distance between corresponding points in the sequences.

The basic steps of the DTW algorithm are as follows:

Define the distance measure: DTW requires a distance measure to calculate the similarity between individual elements of the sequences. Common distance measures include Euclidean distance, Manhattan distance, and correlation-based distance.

Create a cost matrix: Initialize a matrix with dimensions corresponding to the lengths of the two sequences. Each cell in the matrix represents the cumulative distance between the corresponding elements in the sequences.

Initialize the cost matrix: Set the first row and first column of the cost matrix to infinity (or a very large value). This ensures that the algorithm can start from any point in the sequences.

Calculate cumulative distances: Iterate through the cost matrix, starting from the second row and second column. For each cell, calculate the cumulative distance as the sum of the current element's distance and the minimum of the three adjacent cells (above, left, and diagonal). Update the cell with the cumulative distance.

Find the optimal path: Trace back through the cost matrix, starting from the bottom-right cell. At each step, move to the adjacent cell with the minimum cumulative distance. This path represents the optimal alignment between the two sequences.

Compute the similarity score: The final similarity score is the cumulative distance of the optimal path divided by the total number of elements in the sequences.

DTW is widely used in various applications, including speech recognition, gesture recognition, and pattern matching in time series data. Its flexibility in handling sequences of different lengths and capturing temporal variations makes it a powerful tool in analyzing time-dependent data.



